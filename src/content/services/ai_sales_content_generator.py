# src/content/services/ai_sales_content_generator.py
"""
AI-Powered Sales Content Generator
Creates 100% unique content using LLM calls with Universal Sales-Driven Content Framework
Every piece is dynamically generated by AI with no templates or hardcoded content
"""

from typing import List, Optional, Dict, Any, Union
from uuid import UUID, uuid4
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
import logging
import json
import hashlib
import random
import asyncio

# Import AI providers
from src.intelligence.utils.unified_ultra_cheap_provider import UnifiedUltraCheapProvider

logger = logging.getLogger(__name__)

class AISalesContentGenerator:
    """
    AI-powered content generator that creates unique sales-focused content
    Uses LLM calls with our Universal Sales-Driven Content Framework prompts
    NO templates, NO hardcoded content - everything dynamically created by AI
    """

    def __init__(self, db: AsyncSession):
        self.db = db
        self.ai_provider = UnifiedUltraCheapProvider()

    async def generate_unique_ai_content(
        self,
        content_type: str,
        campaign_id: Union[str, UUID],
        user_id: Union[str, UUID],
        company_id: Union[str, UUID],
        preferences: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Generate completely unique content using AI with sales psychology
        Every piece of content is 100% AI-created with conversion focus
        """
        try:
            # Get intelligence data and extract sales variables
            intelligence_data = await self._get_campaign_intelligence_data(campaign_id)

            if not intelligence_data:
                return {
                    "success": False,
                    "error": "No intelligence data available for AI content generation",
                    "required_action": "run_campaign_analysis"
                }

            # Extract sales variables for AI prompts
            sales_variables = await self._extract_sales_variables(intelligence_data)

            # Get user context for personalization
            user_context = await self._get_user_context(user_id, company_id)

            # Generate content using AI with sales-focused prompts
            if content_type in ["email", "email_sequence"]:
                result = await self._generate_ai_email_sequence(
                    intelligence_data, sales_variables, user_context, preferences or {}
                )
            elif content_type == "social_post":
                result = await self._generate_ai_social_content(
                    intelligence_data, sales_variables, user_context, preferences or {}
                )
            elif content_type == "blog_article":
                result = await self._generate_ai_blog_article(
                    intelligence_data, sales_variables, user_context, preferences or {}
                )
            elif content_type == "video_script":
                result = await self._generate_ai_video_script(
                    intelligence_data, sales_variables, user_context, preferences or {}
                )
            elif content_type == "ad_copy":
                result = await self._generate_ai_ad_copy(
                    intelligence_data, sales_variables, user_context, preferences or {}
                )
            else:
                return {
                    "success": False,
                    "error": f"Unsupported content type: {content_type}"
                }

            # Store the AI-generated content
            content_id = await self._store_ai_content(
                campaign_id=campaign_id,
                user_id=user_id,
                company_id=company_id,
                content_type=content_type,
                content_data=result,
                sales_variables=sales_variables,
                intelligence_used=intelligence_data,
                user_context=user_context,
                generation_settings=preferences or {}
            )

            return {
                "success": True,
                "content_id": str(content_id),
                "content_type": content_type,
                "generated_content": result,
                "ai_generated": True,
                "completely_unique": True,
                "sales_framework_applied": True,
                "conversion_optimized": True,
                "intelligence_sources_used": len(intelligence_data)
            }

        except Exception as e:
            logger.error(f"AI sales content generation failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _generate_ai_email_sequence(
        self,
        intelligence_data: List[Dict[str, Any]],
        sales_variables: Dict[str, Any],
        user_context: Dict[str, Any],
        preferences: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate AI-powered 7-email sales sequence using dynamic prompts"""

        # Determine sequence length based on intelligence richness and preferences
        intelligence_richness = self._calculate_intelligence_richness(intelligence_data)
        sequence_length = preferences.get("sequence_length", 7 if intelligence_richness >= 8 else 5)

        # Define the 7-email framework structure
        email_framework = [
            {"type": "problem_agitation", "psychology": "Make the pain unbearable", "day": 1},
            {"type": "problem_revelation", "psychology": "The 'aha moment' - explain the real cause", "day": 3},
            {"type": "solution_introduction", "psychology": "Hope and possibility", "day": 5},
            {"type": "social_proof_explosion", "psychology": "Others like me are succeeding", "day": 7},
            {"type": "urgency_scarcity", "psychology": "Fear of missing out", "day": 10},
            {"type": "objection_crusher", "psychology": "Remove final barriers", "day": 12},
            {"type": "final_call", "psychology": "Now or never", "day": 14}
        ]

        # Generate each email using AI
        emails = []
        selected_framework = email_framework[:sequence_length]

        for i, email_config in enumerate(selected_framework):
            try:
                email = await self._generate_ai_email(
                    email_number=i + 1,
                    email_config=email_config,
                    sales_variables=sales_variables,
                    user_context=user_context,
                    total_in_sequence=sequence_length
                )
                emails.append(email)
            except Exception as e:
                logger.error(f"Failed to generate email {i+1}: {e}")
                # Add fallback email to prevent sequence from breaking
                emails.append(await self._generate_fallback_email(i + 1, sales_variables, user_context))

        return {
            "content": {"emails": emails},
            "ai_generation_metadata": {
                "framework_type": "7_email_sales_psychology_sequence",
                "sequence_length": sequence_length,
                "intelligence_richness": intelligence_richness,
                "all_emails_ai_generated": True,
                "no_templates_used": True,
                "conversion_focus": "move_prospects_closer_to_purchase"
            },
            "personalization_data": {
                "product_name": sales_variables["PRODUCT_NAME"],
                "primary_benefit": sales_variables["PRIMARY_BENEFIT"],
                "target_audience": sales_variables["TARGET_AUDIENCE"],
                "user_customization": user_context.get("uniqueness_seed")
            }
        }

    async def _generate_ai_email(
        self,
        email_number: int,
        email_config: Dict[str, Any],
        sales_variables: Dict[str, Any],
        user_context: Dict[str, Any],
        total_in_sequence: int
    ) -> Dict[str, Any]:
        """Generate individual email using AI with sales psychology prompts"""

        email_type = email_config["type"]
        psychology = email_config["psychology"]

        # Create AI prompt for subject line
        subject_prompt = await self._create_subject_ai_prompt(
            email_type, email_number, sales_variables, psychology
        )

        # Create AI prompt for email body
        body_prompt = await self._create_body_ai_prompt(
            email_type, email_number, sales_variables, user_context, psychology, total_in_sequence
        )

        try:
            # Generate subject line using AI
            subject_result = await self.ai_provider.unified_generate(
                content_type="email_subject",
                prompt=subject_prompt,
                system_message="You are a master copywriter specializing in high-converting email subject lines. Create compelling, curiosity-driven subjects that make people want to open emails. Use sales psychology but avoid spam triggers.",
                max_tokens=100,
                temperature=0.8,
                task_complexity="simple"
            )

            # Generate email body using AI
            body_result = await self.ai_provider.unified_generate(
                content_type="email_body",
                prompt=body_prompt,
                system_message="You are a world-class sales copywriter. Write persuasive, engaging emails that move prospects closer to purchase. Use proven sales psychology and make every word count for conversion.",
                max_tokens=800,
                temperature=0.7,
                task_complexity="medium"
            )

            if subject_result.get("success") and body_result.get("success"):
                subject = self._clean_ai_subject(subject_result["content"])
                body = self._clean_ai_body(body_result["content"])

                # Generate CTA using AI
                cta = await self._generate_ai_cta(email_type, sales_variables)

                return {
                    "email_number": email_number,
                    "subject": subject,
                    "body": body,
                    "cta": cta,
                    "send_day": email_config["day"],
                    "psychology": psychology,
                    "email_type": email_type,
                    "ai_generated": True,
                    "ai_providers_used": [
                        subject_result.get("provider_used"),
                        body_result.get("provider_used")
                    ],
                    "generation_timestamp": datetime.now(timezone.utc).isoformat(),
                    "conversion_intent": self._get_conversion_intent(email_type)
                }

        except Exception as e:
            logger.error(f"AI generation failed for email {email_number}: {e}")
            raise

    async def _create_subject_ai_prompt(
        self,
        email_type: str,
        email_number: int,
        sales_variables: Dict[str, Any],
        psychology: str
    ) -> str:
        """Create AI prompt for generating email subject lines"""

        product_name = sales_variables["PRODUCT_NAME"]
        pain_point = sales_variables["PAIN_POINT"]
        primary_benefit = sales_variables["PRIMARY_BENEFIT"]
        emotional_trigger = sales_variables["EMOTIONAL_TRIGGER"]
        target_audience = sales_variables["TARGET_AUDIENCE"]

        subject_prompts = {
            "problem_agitation": f"""
CREATE A COMPELLING EMAIL SUBJECT LINE

EMAIL TYPE: Problem Agitation (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET AUDIENCE: {target_audience}
PAIN POINT TO AGITATE: {pain_point}
EMOTIONAL TRIGGER: {emotional_trigger}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "Why [pain point] is sabotaging your [desired outcome]"
- "The hidden reason [pain point] keeps happening"
- "WARNING: [pain point] is costing you more than you think"

YOUR TASK:
Create ONE unique, compelling subject line that:
1. Agitates the pain point: {pain_point}
2. Creates urgency and concern
3. Makes {target_audience} feel the cost of inaction
4. Uses psychological triggers related to {emotional_trigger}
5. Mentions {product_name} subtly or not at all (focus on problem)
6. Keeps under 60 characters for mobile
7. Avoids spam words like "FREE", "URGENT", etc.

Generate ONE compelling subject line:
""",

            "problem_revelation": f"""
CREATE A REVEALING EMAIL SUBJECT LINE

EMAIL TYPE: Problem Revelation (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET AUDIENCE: {target_audience}
PAIN POINT TO REVEAL: {pain_point}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "The shocking truth about [problem]"
- "What nobody tells you about [problem]"
- "The real cause of [problem] (revealed)"

YOUR TASK:
Create ONE unique subject line that:
1. Promises to reveal the truth about {pain_point}
2. Creates curiosity and intrigue
3. Positions you as having insider knowledge
4. Makes {target_audience} want to learn more
5. Keeps under 60 characters
6. Builds anticipation for the solution

Generate ONE revelatory subject line:
""",

            "solution_introduction": f"""
CREATE A HOPEFUL EMAIL SUBJECT LINE

EMAIL TYPE: Solution Introduction (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET AUDIENCE: {target_audience}
PRIMARY BENEFIT: {primary_benefit}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "What if [desired outcome] was actually possible?"
- "The [benefit] breakthrough you've been waiting for"
- "Finally: A real solution for [benefit]"

YOUR TASK:
Create ONE unique subject line that:
1. Introduces hope and possibility
2. Focuses on {primary_benefit}
3. Makes {target_audience} believe change is possible
4. Mentions {product_name} or hints at the solution
5. Creates excitement and anticipation
6. Keeps under 60 characters

Generate ONE hopeful subject line:
""",

            "social_proof_explosion": f"""
CREATE A SOCIAL PROOF EMAIL SUBJECT LINE

EMAIL TYPE: Social Proof (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET AUDIENCE: {target_audience}
PRIMARY_BENEFIT: {primary_benefit}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "How [audience] are getting [benefit] with [product]"
- "[Audience] report [benefit] in just days"
- "Real [benefit] results from [audience]"

YOUR TASK:
Create ONE unique subject line that:
1. Shows {target_audience} others like them are succeeding
2. Highlights {primary_benefit} results
3. Creates FOMO (fear of missing out)
4. Builds trust through social validation
5. Mentions {product_name} naturally
6. Keeps under 60 characters

Generate ONE social proof subject line:
""",

            "urgency_scarcity": f"""
CREATE AN URGENT EMAIL SUBJECT LINE

EMAIL TYPE: Urgency & Scarcity (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET AUDIENCE: {target_audience}
PRIMARY_BENEFIT: {primary_benefit}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "Last chance: [benefit] opportunity disappearing soon"
- "[Scarcity element] - doors close at midnight"
- "Final hours for [benefit] access"

YOUR TASK:
Create ONE unique subject line that:
1. Creates genuine urgency about {primary_benefit}
2. Uses scarcity to motivate action
3. Makes {target_audience} fear missing out
4. Mentions {product_name} or the opportunity
5. Implies time limitation
6. Keeps under 60 characters

Generate ONE urgent subject line:
""",

            "objection_crusher": f"""
CREATE AN OBJECTION-HANDLING EMAIL SUBJECT LINE

EMAIL TYPE: Objection Crusher (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET_audience: {target_audience}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "But what if [product] doesn't work for me?"
- "Your biggest concern about [benefit]"
- "The truth about [product] risks"

YOUR TASK:
Create ONE unique subject line that:
1. Addresses common concerns about {product_name}
2. Makes {target_audience} feel understood
3. Promises to address their doubts
4. Creates curiosity about objection handling
5. Shows empathy and understanding
6. Keeps under 60 characters

Generate ONE empathetic subject line:
""",

            "final_call": f"""
CREATE A FINAL CALL EMAIL SUBJECT LINE

EMAIL TYPE: Final Call (Email #{email_number})
PSYCHOLOGY: {psychology}
PRODUCT: {product_name}
TARGET_AUDIENCE: {target_audience}
PRIMARY_BENEFIT: {primary_benefit}

FRAMEWORK EXAMPLES (for inspiration - DO NOT COPY):
- "This is it - final notice for [benefit]"
- "Last call: [product] access ends tonight"
- "Final chance for [benefit] transformation"

YOUR TASK:
Create ONE unique subject line that:
1. Conveys finality and last chance
2. Creates urgency about {primary_benefit}
3. Makes {target_audience} feel this is their last opportunity
4. Mentions {product_name} or the ending opportunity
5. Implies doors are closing forever
6. Keeps under 60 characters

Generate ONE final call subject line:
"""
        }

        return subject_prompts.get(email_type, f"Create a compelling subject line for {product_name} email #{email_number}")

    async def _create_body_ai_prompt(
        self,
        email_type: str,
        email_number: int,
        sales_variables: Dict[str, Any],
        user_context: Dict[str, Any],
        psychology: str,
        total_in_sequence: int
    ) -> str:
        """Create AI prompt for generating email body content"""

        product_name = sales_variables["PRODUCT_NAME"]
        pain_point = sales_variables["PAIN_POINT"]
        primary_benefit = sales_variables["PRIMARY_BENEFIT"]
        emotional_trigger = sales_variables["EMOTIONAL_TRIGGER"]
        target_audience = sales_variables["TARGET_AUDIENCE"]
        credibility_signal = sales_variables["CREDIBILITY_SIGNAL"]
        competitive_advantage = sales_variables["COMPETITIVE_ADVANTAGE"]
        user_name = user_context.get("user_name", "")

        greeting = f"Hi {user_name.split()[0]}," if user_name else "Hi there,"

        body_prompts = {
            "problem_agitation": f"""
WRITE A PROBLEM AGITATION EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Pain Point to Agitate: {pain_point}
- Emotional Trigger: {emotional_trigger}

FRAMEWORK STRATEGY:
This email should make the pain unbearable. Amplify emotional triggers, use visceral language to make the problem feel urgent. NO solution mentioned - pure problem agitation.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Share something uncomfortable but true about {pain_point}
3. Explain how {pain_point} is systematically sabotaging {primary_benefit}
4. Show the hidden costs and consequences of {pain_point}
5. Make {target_audience} feel the urgency of {emotional_trigger}
6. Build anticipation for tomorrow's email
7. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Concerned, urgent, empathetic but direct
LENGTH: 150-250 words
CTA: Soft tease for tomorrow's revelation

Write the complete email body:
""",

            "problem_revelation": f"""
WRITE A PROBLEM REVELATION EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Pain Point: {pain_point}
- Competitive Advantage: {competitive_advantage}
- Credibility Signal: {credibility_signal}

FRAMEWORK STRATEGY:
The "aha moment" - explain the real cause. Reveal why traditional solutions fail and position your approach as different.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Reference yesterday's email about {pain_point}
3. Reveal the REAL cause that nobody talks about
4. Explain why {pain_point} is actually a symptom, not the problem
5. Show why traditional solutions fail
6. Introduce {product_name} as addressing the root cause through {competitive_advantage}
7. Use {credibility_signal} to build authority
8. Tease tomorrow's solution details
9. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Revealing, authoritative, insightful
LENGTH: 200-300 words
CTA: Build anticipation for the solution

Write the complete email body:
""",

            "solution_introduction": f"""
WRITE A SOLUTION INTRODUCTION EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Primary Benefit: {primary_benefit}
- All Benefits: {', '.join(sales_variables.get('ALL_BENEFITS', [])[:3])}
- Credibility Signal: {credibility_signal}

FRAMEWORK STRATEGY:
Hope and possibility. Introduce the solution concept and show how it creates an environment where benefits happen naturally.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Ask what if {primary_benefit} wasn't just possible, but inevitable
3. Explain how {product_name} represents a fundamental shift
4. List 3 key benefits the solution provides
5. Explain how this works WITH natural patterns, not against them
6. Use {credibility_signal} for authority
7. Include a call-to-action to learn more
8. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Hopeful, exciting, possibility-focused
LENGTH: 200-280 words
CTA: "See how {product_name} works"

Write the complete email body:
""",

            "social_proof_explosion": f"""
WRITE A SOCIAL PROOF EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Primary Benefit: {primary_benefit}
- Competitive Advantage: {competitive_advantage}
- Credibility Signal: {credibility_signal}

FRAMEWORK STRATEGY:
Others like me are succeeding. Use multiple customer stories and testimonials to build trust and create FOMO.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Share surprising results from {target_audience} using {product_name}
3. Include 3 realistic customer testimonials/quotes about {primary_benefit}
4. Explain what makes these results possible ({competitive_advantage})
5. Emphasize these are typical experiences, not cherry-picked
6. Use {credibility_signal} to reinforce methodology
7. Include call-to-action to join successful users
8. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Enthusiastic, proof-focused, community-oriented
LENGTH: 250-350 words
CTA: "Join others achieving {primary_benefit}"

Write the complete email body:
""",

            "urgency_scarcity": f"""
WRITE AN URGENCY & SCARCITY EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Primary Benefit: {primary_benefit}
- Emotional Trigger: {emotional_trigger}
- Urgency Factor: {sales_variables.get('URGENCY_FACTOR', 'limited opportunity')}
- Scarcity Element: {sales_variables.get('SCARCITY_ELEMENT', 'limited time offer')}

FRAMEWORK STRATEGY:
Fear of missing out. Create genuine urgency and scarcity to motivate immediate action.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Explain urgent situation developing with {product_name}
3. Detail why access must be limited (quality reasons)
4. Explain the scarcity (time limit, capacity, etc.)
5. Show consequences of waiting
6. Emphasize {emotional_trigger} doesn't get easier with time
7. Include strong call-to-action with deadline
8. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Urgent, concerned, helpful pressure
LENGTH: 200-300 words
CTA: "Secure your access before [deadline]"

Write the complete email body:
""",

            "objection_crusher": f"""
WRITE AN OBJECTION-CRUSHING EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Primary Benefit: {primary_benefit}
- Credibility Signal: {credibility_signal}
- Competitive Advantage: {competitive_advantage}
- Guarantee Terms: {sales_variables.get('GUARANTEE_TERMS', 'satisfaction guarantee')}

FRAMEWORK STRATEGY:
Remove final barriers. Address top objections directly and provide logical/emotional rebuttals.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. Acknowledge common concerns about {product_name}
3. Address 3 main objections:
   - "What if it doesn't work for me?"
   - "What if I waste my money?"
   - "What if I'm different from others?"
4. Use {credibility_signal} and {competitive_advantage} in responses
5. Explain {sales_variables.get('GUARANTEE_TERMS')} as risk reversal
6. Show bigger risk is continuing with {pain_point}
7. Include call-to-action to try risk-free
8. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Understanding, reassuring, logical
LENGTH: 300-400 words
CTA: "Try {product_name} risk-free"

Write the complete email body:
""",

            "final_call": f"""
WRITE A FINAL CALL EMAIL BODY

EMAIL #{email_number} of {total_in_sequence}
PSYCHOLOGY: {psychology}
GREETING: {greeting}
SENDER: {user_context.get('user_name', '[Your Name]')}

CONTEXT:
- Product: {product_name}
- Target Audience: {target_audience}
- Primary Benefit: {primary_benefit}
- Pain Point: {pain_point}
- Price Point: {sales_variables.get('PRICE_POINT', 'special pricing')}

FRAMEWORK STRATEGY:
Now or never. Final push with recap of journey and transformation possible vs. regret of inaction.

CONTENT REQUIREMENTS:
1. Start with {greeting}
2. State this is final message about {product_name}
3. Recap the 2-week journey (problem → revelation → solution → proof → urgency → objections)
4. Present the final decision clearly
5. Compare cost of {product_name} vs. cost of continuing with {pain_point}
6. Paint picture of success with {primary_benefit} vs. regret
7. Include final call-to-action with midnight deadline
8. End with signature from {user_context.get('user_name', '[Your Name]')}

TONE: Final, decisive, transformation-focused
LENGTH: 250-350 words
CTA: "Get {product_name} now - doors close at midnight"

Write the complete email body:
"""
        }

        return body_prompts.get(email_type, f"Write a compelling email body for {product_name} email #{email_number}")

    async def _generate_ai_cta(self, email_type: str, sales_variables: Dict[str, Any]) -> str:
        """Generate AI-powered call-to-action for each email type"""

        product_name = sales_variables["PRODUCT_NAME"]
        primary_benefit = sales_variables["PRIMARY_BENEFIT"]

        cta_prompt = f"""
CREATE A COMPELLING CALL-TO-ACTION

EMAIL TYPE: {email_type}
PRODUCT: {product_name}
PRIMARY BENEFIT: {primary_benefit}

Generate ONE short, compelling call-to-action button text (2-6 words) that matches the email type:

For {email_type} emails, create a CTA that encourages the next step in the sales sequence.

CTA Text:
"""

        try:
            cta_result = await self.ai_provider.unified_generate(
                content_type="cta_generation",
                prompt=cta_prompt,
                system_message="Generate short, compelling call-to-action text that drives clicks and conversions. Keep it under 6 words.",
                max_tokens=20,
                temperature=0.6,
                task_complexity="simple"
            )

            if cta_result.get("success"):
                return cta_result["content"].strip().strip('"').strip("'")

        except Exception as e:
            logger.error(f"AI CTA generation failed: {e}")

        # Fallback CTAs
        cta_fallbacks = {
            "problem_agitation": f"Learn More About {primary_benefit}",
            "problem_revelation": f"Discover The Real Solution",
            "solution_introduction": f"See How {product_name} Works",
            "social_proof_explosion": f"Join Successful {sales_variables['TARGET_AUDIENCE']}",
            "urgency_scarcity": f"Secure Your Access Now",
            "objection_crusher": f"Try {product_name} Risk-Free",
            "final_call": f"Get {product_name} Now"
        }

        return cta_fallbacks.get(email_type, f"Learn More About {product_name}")

    def _clean_ai_subject(self, ai_content: str) -> str:
        """Clean AI-generated subject line"""
        lines = ai_content.strip().split('\n')
        for line in lines:
            line = line.strip()
            # Remove common prefixes and clean
            line = line.replace("Subject:", "").replace("Subject Line:", "").strip()
            line = line.strip('"').strip("'").strip()
            if 10 <= len(line) <= 80 and line:
                return line
        return ai_content.strip()[:80]  # Fallback

    def _clean_ai_body(self, ai_content: str) -> str:
        """Clean AI-generated email body"""
        return ai_content.strip()

    async def _generate_fallback_email(
        self,
        email_number: int,
        sales_variables: Dict[str, Any],
        user_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate fallback email if AI generation fails"""

        product_name = sales_variables["PRODUCT_NAME"]
        primary_benefit = sales_variables["PRIMARY_BENEFIT"]
        user_name = user_context.get("user_name", "")
        greeting = f"Hi {user_name.split()[0]}," if user_name else "Hi there,"

        return {
            "email_number": email_number,
            "subject": f"{product_name}: Important Update #{email_number}",
            "body": f"""{greeting}

I wanted to share an important update about {product_name} and how it can help you achieve {primary_benefit}.

This is part of a series of insights I'm sharing to help you understand the full potential of this approach.

More details coming in the next message.

Best regards,
{user_context.get('user_name', '[Your Name]')}""",
            "cta": f"Learn More About {product_name}",
            "send_day": email_number * 2,
            "psychology": "informational",
            "email_type": "fallback",
            "ai_generated": False,
            "is_fallback": True,
            "generation_timestamp": datetime.now(timezone.utc).isoformat(),
            "conversion_intent": "engagement"
        }

    def _get_conversion_intent(self, email_type: str) -> str:
        """Get conversion intent for email type"""
        intent_map = {
            "problem_agitation": "awareness",
            "problem_revelation": "interest",
            "solution_introduction": "consideration",
            "social_proof_explosion": "evaluation",
            "urgency_scarcity": "conversion",
            "objection_crusher": "conversion",
            "final_call": "conversion"
        }
        return intent_map.get(email_type, "engagement")

    # Add more AI generation methods for other content types...
    # (social_post, blog_article, video_script, ad_copy)

    def _calculate_intelligence_richness(self, intelligence_data: List[Dict[str, Any]]) -> float:
        """Calculate intelligence richness score"""
        if not intelligence_data:
            return 0.0

        primary_intel = intelligence_data[0]
        score = 0.0

        # Score elements important for sales content
        score += len(primary_intel.get("benefits", [])) * 0.3
        score += len(primary_intel.get("features", [])) * 0.2
        score += len(primary_intel.get("competitive_advantages", [])) * 0.25
        score += len(primary_intel.get("research_content", [])) * 0.15
        score += 0.1 if primary_intel.get("positioning") else 0
        score += primary_intel.get("confidence_score", 0) * 0.2

        return min(score, 10.0)

    async def _extract_sales_variables(self, intelligence_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Extract sales variables from intelligence data"""
        if not intelligence_data:
            raise ValueError("No intelligence data available")

        primary_intel = intelligence_data[0]

        # Extract key sales variables
        product_name = primary_intel.get("product_name", "").strip()
        benefits = primary_intel.get("benefits", [])
        features = primary_intel.get("features", [])
        competitive_advantages = primary_intel.get("competitive_advantages", [])

        # Extract pain points from research
        pain_points = self._extract_pain_points(intelligence_data)

        return {
            "PRODUCT_NAME": product_name,
            "PRIMARY_BENEFIT": benefits[0] if benefits else "improved results",
            "PAIN_POINT": pain_points[0] if pain_points else "current challenges",
            "TARGET_AUDIENCE": primary_intel.get("target_audience", "professionals"),
            "EMOTIONAL_TRIGGER": "desire for improvement",
            "CREDIBILITY_SIGNAL": "proven approach",
            "COMPETITIVE_ADVANTAGE": competitive_advantages[0] if competitive_advantages else "unique methodology",
            "GUARANTEE_TERMS": "satisfaction guarantee",
            "PRICE_POINT": "special pricing",
            "URGENCY_FACTOR": "limited opportunity",
            "SCARCITY_ELEMENT": "limited time offer",
            "ALL_BENEFITS": benefits,
            "ALL_FEATURES": features,
            "ALL_COMPETITIVE_ADVANTAGES": competitive_advantages
        }

    def _extract_pain_points(self, intelligence_data: List[Dict[str, Any]]) -> List[str]:
        """Extract pain points from intelligence data"""
        pain_points = []

        for intel in intelligence_data:
            research_content = intel.get("research_content", [])
            for research in research_content:
                content = research.get("content", "").lower()
                pain_indicators = ["problem", "challenge", "struggle", "difficulty", "frustration"]

                if any(indicator in content for indicator in pain_indicators):
                    sentences = research["content"].split('. ')
                    for sentence in sentences:
                        if any(indicator in sentence.lower() for indicator in pain_indicators):
                            clean_sentence = sentence.strip()
                            if 20 <= len(clean_sentence) <= 150:
                                pain_points.append(clean_sentence)

        if not pain_points:
            category = intelligence_data[0].get("category", "solutions")
            pain_points = [
                f"ineffective {category.lower()}",
                "lack of results",
                "wasted time and money"
            ]

        return pain_points[:5]

    # Database methods (reuse from previous service)
    async def _get_campaign_intelligence_data(self, campaign_id: Union[str, UUID]) -> List[Dict[str, Any]]:
        """Get intelligence data from database"""
        try:
            query = text("""
                SELECT
                    ic.id as intelligence_id,
                    ic.product_name,
                    ic.salespage_url,
                    ic.confidence_score,
                    ic.analysis_method,
                    ic.full_analysis_data,
                    pd.features,
                    pd.benefits,
                    pd.ingredients,
                    pd.conditions,
                    pd.usage_instructions,
                    md.category,
                    md.positioning,
                    md.competitive_advantages,
                    md.target_audience,
                    kb.content as research_content,
                    kb.research_type
                FROM intelligence_core ic
                LEFT JOIN product_data pd ON ic.id = pd.intelligence_id
                LEFT JOIN market_data md ON ic.id = md.intelligence_id
                LEFT JOIN intelligence_research ir ON ic.id = ir.intelligence_id
                LEFT JOIN knowledge_base kb ON ir.research_id = kb.id
                WHERE ic.user_id IN (
                    SELECT user_id FROM campaigns WHERE id = :campaign_id
                )
                ORDER BY ic.confidence_score DESC, ic.created_at DESC
            """)

            result = await self.db.execute(query, {"campaign_id": UUID(str(campaign_id))})
            rows = result.fetchall()

            # Group intelligence data
            intelligence_map = {}
            for row in rows:
                intel_id = row.intelligence_id

                if intel_id not in intelligence_map:
                    intelligence_map[intel_id] = {
                        "intelligence_id": str(intel_id),
                        "product_name": row.product_name,
                        "salespage_url": row.salespage_url,
                        "confidence_score": float(row.confidence_score) if row.confidence_score else 0.0,
                        "analysis_method": row.analysis_method,
                        "full_analysis_data": row.full_analysis_data if row.full_analysis_data else {},
                        "features": row.features if row.features else [],
                        "benefits": row.benefits if row.benefits else [],
                        "ingredients": row.ingredients if row.ingredients else [],
                        "conditions": row.conditions if row.conditions else [],
                        "usage_instructions": row.usage_instructions if row.usage_instructions else [],
                        "category": row.category,
                        "positioning": row.positioning,
                        "competitive_advantages": row.competitive_advantages if row.competitive_advantages else [],
                        "target_audience": row.target_audience,
                        "research_content": []
                    }

                if row.research_content and row.research_type:
                    intelligence_map[intel_id]["research_content"].append({
                        "content": row.research_content,
                        "research_type": row.research_type
                    })

            return list(intelligence_map.values())

        except Exception as e:
            logger.error(f"Failed to get intelligence data: {e}")
            return []

    async def _get_user_context(self, user_id: Union[str, UUID], company_id: Union[str, UUID]) -> Dict[str, Any]:
        """Get user context for personalization"""
        try:
            query = text("""
                SELECT
                    u.id as user_id,
                    u.full_name,
                    u.user_type,
                    c.company_name,
                    c.industry,
                    COUNT(camp.id) as total_campaigns
                FROM users u
                JOIN companies c ON u.company_id = c.id
                LEFT JOIN campaigns camp ON camp.user_id = u.id
                WHERE u.id = :user_id AND c.id = :company_id
                GROUP BY u.id, c.id
            """)

            result = await self.db.execute(query, {
                "user_id": UUID(str(user_id)),
                "company_id": UUID(str(company_id))
            })
            row = result.fetchone()

            if not row:
                return {"user_id": str(user_id), "uniqueness_seed": str(user_id)[:8]}

            return {
                "user_id": str(row.user_id),
                "user_name": row.full_name,
                "user_type": row.user_type,
                "company_name": row.company_name,
                "industry": row.industry,
                "experience_level": "experienced" if row.total_campaigns > 5 else "new",
                "uniqueness_seed": hashlib.md5(f"{user_id}-{company_id}".encode()).hexdigest()[:8]
            }

        except Exception as e:
            logger.error(f"Failed to get user context: {e}")
            return {"user_id": str(user_id), "uniqueness_seed": str(user_id)[:8]}

    async def _store_ai_content(
        self,
        campaign_id: Union[str, UUID],
        user_id: Union[str, UUID],
        company_id: Union[str, UUID],
        content_type: str,
        content_data: Dict[str, Any],
        sales_variables: Dict[str, Any],
        intelligence_used: List[Dict[str, Any]],
        user_context: Dict[str, Any],
        generation_settings: Dict[str, Any]
    ) -> UUID:
        """Store AI-generated content with metadata"""

        content_id = uuid4()

        # Generate AI-focused title
        content_title = f"AI-Generated {content_type.title()}: {sales_variables['PRODUCT_NAME']} Sales Content"

        # Extract content for storage
        if content_type in ["email", "email_sequence"]:
            emails = content_data.get("content", {}).get("emails", [])
            content_body = json.dumps(emails)
        else:
            content_body = json.dumps(content_data.get("content", {}))

        # Create metadata emphasizing AI generation
        content_metadata = {
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "ai_generated": True,
            "completely_unique": True,
            "no_templates_used": True,
            "sales_framework_applied": True,
            "ai_generation_metadata": content_data.get("ai_generation_metadata", {}),
            "personalization_data": content_data.get("personalization_data", {}),
            "sales_variables_used": list(sales_variables.keys()),
            "intelligence_sources": len(intelligence_used),
            "user_customization": user_context.get("uniqueness_seed"),
            "generation_method": "ai_dynamic_unique",
            "framework_version": "universal_sales_driven_ai_v1.0"
        }

        query = text("""
            INSERT INTO generated_content
            (id, user_id, campaign_id, company_id, content_type, content_title, content_body,
             content_metadata, generation_settings, generation_method, content_status, intelligence_id)
            VALUES (:id, :user_id, :campaign_id, :company_id, :content_type, :content_title,
                    :content_body, :content_metadata, :generation_settings, 'ai_sales_focused', 'generated', :intelligence_id)
        """)

        await self.db.execute(query, {
            "id": content_id,
            "user_id": UUID(str(user_id)),
            "campaign_id": UUID(str(campaign_id)),
            "company_id": UUID(str(company_id)),
            "content_type": content_type,
            "content_title": content_title,
            "content_body": content_body,
            "content_metadata": json.dumps(content_metadata),
            "generation_settings": json.dumps(generation_settings),
            "intelligence_id": intelligence_used[0]["intelligence_id"] if intelligence_used else None
        })

        await self.db.commit()
        return content_id